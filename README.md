# REAL CODE PROBLEMS:

**Authors:**
[Brian Zhao](https://github.com/jian10au),
[Nathan Pallet](https://github.com/Farts-Jousta),
[Emma Cullen](https://github.com/mcbadger88),
[Taya Lacey](https://github.com/tayaaaa)

**Client:**
[Micheal Milewski](https://github.com/saramic)
 
**Backend repo:** https://github.com/mcbadger88/real-code-problems-backend

**Frontend repo:** https://github.com/mcbadger88/real-code-problems-frontend


**Project Brief:**
-
For our final assignment, we were asked to build, design and deploy a MERN stack application that solves a problem while working with a real-world client. (Michael Milewski). 

**Purpose:**
-
This project is a coding playground that presents real world problems for developers to solve. Unlike other coding sites that focus on algorithmic problems, real code problems presents coding challenges that could help you build a full-stack project such as a blog challenge or online marketplace.

**Target audience:**
-
Real code problems is perfect for:

- Students + Job seekers:
    - Looking for more practise on projects where they can receive feedback from a test suite
    - Looking to develop a portfolio of work visible to employers that meets the employers standards and requirements
- Employers:
    - Employers who want to assign challenges and see an overview of the work of developers side-by-side
    - Who want to see which developers have completed relevant problems and approach them for work opportunities.

**Features and User stories:**
-
![user stories](/resources/readme/user-stories.png "User stories")

**Userflow Diagram:**
-
![Userflow diagram](/resources/readme/userflow-diagram.png "Userflow diagram")

# App design:

**Tech stack:**
-
We used the MERN stack to complete this project:

- *M*ongoDB: We used a mongodb database to store all the user information and status of the candidates code submissions.

- *E*xpress: Our API backend was written in express. 
- *R*eact: The frontend of the app is written in react.
- *N*ode.js: The rest of the app is written in node.js

The test runner that checked the submitted problems was written in ruby on rails.

**Application architecture diagram:**
-
![app architecture diagram](/resources/readme/app-architecture.png "app architecture diagram")

**Dataflow diagram:**
-
![Dataflow diagram](/resources/readme/dataflow-diagram.png "Dataflow diagram")

**ERD:**
-
![Entity relationship diagram](/resources/readme/erd-diagram.png "Mockup: Candidate dashboard")

**Sitemap:**
-
![sitemap](/resources/readme/sitemap.png "sitemap")

# Front-end design:

**Style guide / rules:**
-
We made a simple style guide to make sure our mockups were consistent.
![style guide](/resources/readme/style-guide.png "style guide")

**Wireframes + Mockups:**
-

Candidate dashboard:
![Wireframe: Candidate dashboard](/resources/readme/wf-can-dash.png "wireframe: Candidate dashboard")
![Mockup: Candidate dashboard](/resources/readme/mu-can-dash.png "Mockup: Candidate dashboard")


Browse all challenges:
![Wireframe: Browse all challenges](/resources/readme/wf-browse-challs.png "wireframe: browse all challenges")
![Mockup: Browse all challenges](/resources/readme/mu-browse-challs.png "Mockup: browse all challenges")

Show individual challenge:
![Wireframe: show individual challenge](/resources/readme/wf-show-chall.png "wireframe: show individual challenge")
![Mockup: show individual challenge](/resources/readme/mu-show-chall.png "Mockup: show individual challenge")

Landing page:
![Mobile: Landing page](/resources/readme/mu-landing-mobile.png "Mobile: Landing page")
![Desktop: Landing page](/resources/readme/mu-landing-desktop.png "Desktop: Landing page")

Candidate Profile:
![Desktop mockup: show individual challenge](/resources/readme/mu-can-profile.png "Desktop mockup: candidate profile")
![Mobile mockup: show individual challenge](/resources/readme/mu-profile-mobile.png "Mobile mockup: candidate profile")

# Source control process:

**Github:**
-
We created two github repos for the front and backend of our app. We were all collaborators and cloned the project. We created a new branch for each feature and pushed our changes to that branch. 

Once that feature was ready to be merged with master we made sure that another team member reviewed any merge conflicts before pushing to master.

**Trello**
-
We used to trello to keep track of all the tasks at hand and assign different parts of the project to our team members. Here are some screenshots of our trello board:
![trello board 1](/resources/readme/trello-1.png "Trello board 1")

![Trello board 2](/resources/readme/trello-2.png "Trello board 2")



